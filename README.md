# 1. Основы ботоводства

Для того, чтобы приступить к изучению курса, нужно проверить свой уровень. 

Напишите программу на Python, которая запрашивает у пользователя его имя и определяет его "цвет" на основе следующих критериев:

**Сумма ASCII-кодов символов:**

- Если сумма ASCII-кодов всех символов в имени четная, то цвет — "синий".
- Если сумма кратна трём, то цвет — "зеленый".
- Если сумма кратна и двум, и трём одновременно, то цвет — "серый".
- Если не подходит ни под одно условие, то цвет — "красный".

**Длина имени:**

-    Если длина имени больше 10 символов, то к цвету добавляется приставка "светло-".
-    Если длина имени меньше 5 символов, то к цвету добавляется приставка "темно-".

Примечание:

```
print(ord('w'))  # Вывод: 119
```

### Регистрация бота в Telegram

В этом уроке мы рассмотрим, как создать бота в Telegram и получить его уникальный токен, который необходим для взаимодействия с Telegram Bot API. Это первый шаг в разработке вашего собственного телеграм-бота.
#### Шаг 1: Установка Telegram и поиск BotFather

- Установите Telegram: Если у вас еще нет Telegram, скачайте и установите приложение с официального сайта telegram.org или из магазина приложений вашего устройства.
- Откройте Telegram и войдите в систему: Используйте ваш номер телефона или логин, чтобы войти в приложение.
- Найдите BotFather: В строке поиска введите @BotFather и выберите официального бота от Telegram.
#### Шаг 2: Создание нового бота

**Начните диалог с BotFather:**

- Нажмите кнопку "Start" или отправьте команду /start, чтобы начать взаимодействие с BotFather.

**Создайте нового бота:**

- Отправьте команду /newbot в чате с BotFather.
- BotFather попросит вас ввести имя для вашего бота. Это имя будет отображаться в списке контактов и в верхней части чата. Введите желаемое имя, например, "MyFirstBot".

**Укажите имя пользователя для бота:**

- После ввода имени BotFather попросит вас указать имя пользователя для вашего бота. Имя пользователя должно быть уникальным и заканчиваться на bot (например, MyFirstBot_bot).
- Введите имя пользователя и подтвердите его.

**Получите токен**

- После успешного создания бота BotFather отправит вам сообщение с токеном вашего бота. Этот токен выглядит как строка из букв и цифр, например: 123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11

- **Важно**: Сохраните этот токен в безопасном месте, так как он необходим для управления вашим ботом и взаимодействия с Telegram API.

#### Шаг 3: Настройка бота (опционально)

**Настройка описания и информации:**

- Вы можете использовать команды, предоставляемые BotFather, для настройки описания, информации о боте, аватарки и других параметров.
- Например, используйте команду /setdescription, чтобы добавить описание вашему боту.

**Настройка команд:**

- Используйте команду /setcommands, чтобы определить команды, которые будет поддерживать ваш бот.
- Это позволит пользователям видеть список доступных команд при нажатии на кнопку "Commands" в чате с ботом.

#### Шаг 4: Проверка бота

- **Найдите вашего бота в Telegram**: Используйте имя пользователя, которое вы указали, чтобы найти вашего бота в Telegram.
- **Начните диалог с ботом**: Нажмите кнопку "Start" или отправьте команду /start, чтобы начать взаимодействие с ботом.
- **Тестирование**: Попробуйте отправить несколько команд и сообщений, чтобы убедиться, что бот реагирует. Пока что он не будет выполнять никаких действий, так как мы еще не написали для него код.

#### Дополнительные советы:

- **Безопасность**: Никогда не передавайте токен вашего бота другим людям, так как это может привести к несанкционированному доступу и управлению вашим ботом.
- **Управление ботом**: Вы можете использовать BotFather для изменения настроек, добавления новых команд и управления другими аспектами вашего бота в любое время.
- **Документация**: Ознакомьтесь с официальной документацией Telegram Bot API для получения более подробной информации о возможностях и функциях ботов.
#### Задать аватар, описание и команды

Чтобы придать "товарный вид" вашему телеграм-боту, нужно использовать BotFather — официального бота Telegram для управления ботами. Вот как это сделать:

#### 1. Установка Аватарки (Картинки)

- Откройте диалог с BotFather: Найдите @BotFather в Telegram и начните с ним диалог, если еще не сделали этого.
- Выберите вашего бота: Используйте команду /mybots, чтобы увидеть список всех ваших ботов.
- Выберите бот для редактирования: Из списка выберите бот, которому вы хотите установить аватар.
- Загрузите аватар, используя команду /setuserpic
- BotFather попросит вас загрузить изображение. Отправьте изображение, которое вы хотите использовать в качестве аватара для вашего бота.
- Примечание: Изображение должно быть в формате JPG, PNG или GIF и не должно превышать 256 КБ.
- Подтверждение: После загрузки BotFather подтвердит изменение аватара.

#### 2. Установка Описания

- Откройте диалог с BotFather: Если вы еще не сделали этого, найдите @BotFather и начните с ним диалог.
- Выберите вашего бота: Используйте команду /mybots, чтобы увидеть список всех ваших ботов.
- Выберите бот для редактирования: Из списка выберите бот, которому вы хотите установить описание.
- Установите описание используя команду /setdescription
- BotFather попросит вас ввести новое описание для вашего бота.
- Введите текст, который будет отображаться как описание вашего бота.
- Пример: "Этот бот поможет вам управлять вашими задачами и напоминаниями."
- Подтверждение: BotFather подтвердит изменение описания.

#### 3. Установка Команд

- Откройте диалог с BotFather: Найдите @BotFather и начните с ним диалог.
- Выберите вашего бота: Используйте команду /mybots, чтобы увидеть список всех ваших ботов.
- Выберите бот для редактирования: Из списка выберите бот, для которого вы хотите установить команды.
- Установите команды используя команду /setcommands.
- BotFather попросит вас ввести список команд в определенном формате. Каждая команда должна быть описана в отдельной строке в формате `команда1 - описание команды1`.
- Подтверждение: BotFather подтвердит изменение списка команд.

**Пример:**

```
start - Начать работу с ботом
help - Получить справку по командам
settings - Настроить параметры
taskadd - Добавить новую задачу
tasklist - Показать список задач
```

#### Что ещё:

- **Обновление команд**: Вы можете в любой момент обновить список команд, повторно используя команду `/setcommands` и предоставив новый список.
- **Описание и команды**: Хорошо продуманное описание и список команд помогут пользователям лучше понять, что может делать ваш бот и как его использовать.
- **Тестирование**: После настройки аватара, описания и команд протестируйте их, чтобы убедиться, что все работает как ожидается.

## Основы сетевых запросов (GET и POST)

Веб-приложения и API часто взаимодействуют с серверами с помощью HTTP-запросов. Двумя наиболее распространенными методами HTTP-запросов являются GET и POST.
GET-запросы

GET-запросы используются для получения данных с сервера. Они не должны изменять состояние сервера и обычно применяются для извлечения информации.

**Особенности**

- Данные передаются в URL в виде параметров запроса.
- Можно добавлять параметры в конец URL после знака вопроса (?), разделяя их амперсандом (&).

#### getMe

#### Бот получает информацию о самом себе

https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/getMe

Что здесь происходит:

1. В строке явно виден токен, который мы получили при регистрации бота

`123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11`

2. Стока заканчивается ключом getMe

Перейдите по этой ссылке и вам ответит сервер Телеграм. В ответе будет видна информация о вашем боте.

`{`
  `"ok": true,`
  `"result": {`
    `"id": 123456,`
    `"is_bot": true,`
    `"first_name": "Test",`
    `"username": "Test",`
    `"can_join_groups": true,`
    `"can_read_all_group_messages": false,`
    `"supports_inline_queries": false,`
    `"can_connect_to_business": false,`
    `"has_main_web_app": false`
  `}`
`}`

**Используем Python**

`import requests`

`token = "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"`
`key = "getMe"`
`url = f"https://api.telegram.org/bot{token}/{key}"`
`response = requests.get(url, timeout=30)`
`print(response.status_code)  # Вывод: 200`
`print(response.json())`

**Вывод**

`{'ok': True, 'result': {'id': 123456, 'is_bot': True, 'first_name': 'Test', 'username': 'Test', 'can_join_groups': True, 'can_read_all_group_messages': False, 'supports_inline_queries': False, 'can_connect_to_business': False, 'has_main_web_app': False}}`

Что здесь происходит:

Сначала создаётся url из токена и ключа.

Затем делается запрос методом GET. Это аналог того, что мы делали только что в браузере.
getUpdates

### Бот получает информацию о действиях пользователей

`https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/getUpdates`

**Используем Python**

`import requests`

`token = "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"`
`key = "getUpdates"`
`url = f"https://api.telegram.org/bot{token}/{key}"`
`response = requests.get(url, timeout=30)`
`print(response.json())`

Вывод

`{'ok': True, 'result': []}`

Видно, что к боту в последнее время никто не обращался. Список result пуст. Напишите боту что-нибудь и проверьте, что получится.

`{`
    `"ok": true,`
    `"result": [`
        `{`
            `"update_id": 111,`
            `"message": {`
                `"message_id": 1,`
                `"from": {`
                    `"id": 1234567890,`
                    `"is_bot": false,`
                    `"first_name": "User",`
                    `"username": "username",`
                    `"language_code": "ru",`
                    `"is_premium": true`
                `},`
                `"chat": {`
                    `"id": 1234567890,`
                    `"first_name": "User",`
                    `"username": "username",`
                    `"type": "private"`
                `},`
                `"date": 1738335868,`
                `"text": "/start",`
                `"entities": [`
                    `{`
                        `"offset": 0,`
                        `"length": 6,`
                        `"type": "bot_command"`
                    `}`
                `]`
            `}`
        `}`
    `]`
`}`

Теперь в списке result появилась информация о том, кто и что написал боту.

В блоке message:

- message_id - порядковый номер действия с ботом

В блоке from:

- id - Телеграм ID пользователя. Основное, что нужно, чтобы отправить сообщение пользователю.
- first_name, last_name - Имя и фамилия пользователя
- username - Username пользователя
- date - Unix-время, когда было отправлено сообщение
- text - Текст сообщения, которое послал пользователь боту

Теперь мы знаем кому можно написать.

#### sendMessage

#### Отправить сообщение пользователю

`https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/sendMessage?chat_id=1234567890&text=Привет,+как+дела`

Что здесь происходит

1. К уже известной строке URL добавляются GET-параметры после ? следуют парами и разделяются &. Если в текстовом сообщении есть пробелы, то их нужно заменить на спецсимволы или +. Если встретятся вопросы или ампесанды, то их тоже нужно заменить.

`?chat_id=1234567890&text=Привет,+как+дела`

Так можно отправить сообщение в качестве эксперимента, но организовывать работу бота таким образом нельзя.

Используем Python
```
import requests

token = "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"
key = "sendMessage"
text = "Привет, как дела"
text = text.replace(" ", "+")
url = f"https://api.telegram.org/bot{token}/{key}"
params = {"chat_id": 1234567890, "text": text}
response = requests.get(url, params=params, timeout=30)
print(response.json())
```
 
### POST-запросы

POST-запросы используются для отправки данных на сервер, чтобы создать или обновить ресурс. Они могут изменять состояние сервера.

Особенности

- Данные передаются в теле запроса, а не в URL.
- Более безопасно передавать конфиденциальную информацию, так как она не отображается в URL.
- Пример: отправка формы с данными.

 Пример
```
import requests

token = "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"
key = "sendMessage"
text = "Привет, как дела"
text = text.replace(" ", "+")
url = f"https://api.telegram.org/bot{token}/{key}"
params = {"chat_id": 1234567890, "text": text}
response = requests.post(url, params=params, timeout=30)
print(response.json())
```

Ключевые различия:

- Передача данных: GET передает данные в URL, POST — в теле запроса.
- Безопасность: POST более безопасен для передачи чувствительных данных, так как они не отображаются в URL.
- Изменение состояния: GET не должен изменять состояние сервера, в то время как POST может.

Практическое применение:

- Используйте GET для запросов, которые не изменяют данные на сервере, например, для получения информации.
- Используйте POST для операций, которые изменяют данные, например, для отправки форм или создания новых записей.

## Задание

1. Создайте и зарегистрируйте нового телеграм-бота через @BotFather. Настройте его аватар и описание, чтобы придать ему индивидуальность.

2. Получите имя пользователя вашего бота и сохраните токен в безопасном месте.

3. Отправьте имя вашего бота в качестве ответа.



# 2. Hello, world!

## Виртуальное окружение

Виртуальное окружение (virtual environment) — это изолированная среда для проектов Python, которая позволяет управлять зависимостями проекта без конфликтов с другими проектами или глобальной установкой пакетов.
Зачем нужны виртуальные окружения?

    Изоляция зависимостей: Каждое виртуальное окружение имеет свой собственный набор установленных пакетов. Это предотвращает конфликты между различными проектами, которые могут использовать разные версии одних и тех же пакетов.
    Управление зависимостями:  Вы можете точно контролировать, какие пакеты и их версии установлены в каждом проекте, используя файлы requirements.txt.
    Портативность:  Виртуальное окружение можно легко переносить на другие машины, просто скопировав его и установив необходимые пакеты из requirements.txt.
    Чистота глобальной среды:  Установка пакетов в виртуальное окружение не загрязняет глобальную среду Python, что делает её более чистой и управляемой.

Как создать виртуальное окружение:
1. Использование venv:

python3 -m venv .venv

Заменяем .venv на желаемое имя директории для виртуального окружения.
2. Активация виртуального окружения:
 Linux/macOS:

source .venv/bin/activate

Windows:

.venv\Scripts\activate

После активации, в командной строке вы увидите имя виртуального окружения в скобках (например, (.venv) $).
3. Установка пакетов:

# Пример
pip install <package_name>

# Для установки библиотеки telebot
pip install pyTelegramBotAPI

4. Запись зависимостей в requirements.txt:

pip freeze > requirements.txt

5. Восстановление зависимостей из requirements.txt:

pip install -r requirements.txt

6. Деактивация виртуального окружения:

deactivate

Пример использования:

Представьте, что у вас два проекта: один использует Django 2.2, а другой — Django 3.2. Если вы установите оба фреймворка глобально, возникнет конфликт.

Вместо этого, вы создадите два виртуальных окружения:
Проект 1 (Django 2.2):

    Создать виртуальное окружение: python3 -m venv .venv_project1
    Активировать: source .venv_project1/bin/activate
    Установить Django 2.2: pip install Django==2.2

Проект 2 (Django 3.2):

    Создать виртуальное окружение: python3 -m venv .venv_project2
    Активировать: source .venv_project2/bin/activate
    Установить Django 3.2: pip install Django==3.2

Таким образом, каждый проект будет иметь свою изолированную среду с нужными версиями пакетов, и конфликтов не возникнет.
Вывод:

Использование виртуальных окружений — это лучшая практика при разработке на Python. Оно позволяет избежать множества проблем, связанных с управлением зависимостями и обеспечивает чистоту вашей рабочей среды.


## 2.2 Купи слона 



Библиотека telebot (или pyTelegramBotAPI) — это популярная библиотека для создания Telegram-ботов на Python. Она проста в использовании и хорошо документирована. Давайте создадим простого эхо-бота с использованием этой библиотеки.
Шаг 1: Установка библиотеки

Сначала установите библиотеку pyTelegramBotAPI. Вы можете сделать это с помощью pip:

# pip install pyTelegramBotAPI


pip install --proxy http://<>:<>@<>:<> pyTelegramBotAPI

Шаг 2: Создание бота в Telegram

Если вы еще этого не сделали, создайте бота через BotFather в Telegram и получите токен доступа.
Шаг 3: Написание кода для эхо-бота

Теперь напишем код для простого эхо-бота:

import telebot
import os


proxy = 'http://<>:<>@<>:<>'
os.environ['http_proxy'] = proxy
os.environ['HTTP_PROXY'] = proxy
os.environ['https_proxy'] = proxy
os.environ['HTTPS_PROXY'] = proxy


# Вставьте ваш токен сюда
TOKEN = 'YOUR_TELEGRAM_BOT_TOKEN'
bot = telebot.TeleBot(TOKEN)

# Функция для обработки команды /start
@bot.message_handler(commands=['start'])
def send_welcome(message):
    bot.reply_to(message, "Привет! Я эхо-бот. Напиши мне что-нибудь!")

# Функция для обработки текстовых сообщений
@bot.message_handler(func=lambda message: True)
def echo_all(message):
    bot.reply_to(message, message.text)

# Запуск бота
bot.polling()

Шаг 4: Запуск бота

    Замените YOUR_TELEGRAM_BOT_TOKEN на токен, который вы получили от @BotFather
    Сохраните код в файл, например, echo_bot.py
    Запустите скрипт:

python echo_bot.py

Шаг 5: Тестирование бота

Теперь откройте Telegram, найдите своего бота по имени и напишите ему сообщение. Бот должен ответить тем же текстом.
Задание

Исправьте код нашего эхо-бота так, чтобы получилась игра "Купи слона".
Что ещё сделать?

    Вы можете добавить больше команд, используя декораторы @bot.message_handler(commands=['command_name'])
    Можно обрабатывать различные типы сообщений (фото, видео и т.д.) и добавлять дополнительные функции, такие как кнопки или inline-меню.
    Изучите документацию библиотеки pyTelegramBotAPI, чтобы узнать о всех возможностях



#  3. Структуры и функции 

## 3.1 Анаграмма 



Сегодня будем играть в анаграммы. Будем составлять слова из букв другого слова. Исходное слово задаёт программист-владелец бота. Все пользователи - игроки.

import telebot


proxy = "http://<>:<>@<>:<>"
os.environ["http_proxy"] = proxy
os.environ["HTTP_PROXY"] = proxy
os.environ["https_proxy"] = proxy
os.environ["HTTPS_PROXY"] = proxy


# Вставьте ваш токен сюда
TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
bot = telebot.TeleBot(TOKEN)

anagrams_lst = list()

word = "Апельсинка"


@bot.message_handler(commands=["start"])
def start_game(message):
    bot.send_message(message.chat.id, f"Придумай анаграмму к слову {word}.")


@bot.message_handler(func=lambda message: True)
def anagrama_message(message):
    # Получение данных
    text = message.text
    # Обработка данных
    if text in anagrams_lst:
        msg = "Такое слово уже называли!"
    else:
        msg = f"Спасибо. Запомню слово {text}."
    # Вывод данных
    bot.reply_to(message, msg)


if __name__ == "__main__":
    bot.polling(none_stop=True)

Что тут происходит

Начальное слово задано в переменной word. Его можно изменить, но тогда придётся остановить программу и пропадёт список "придуманных" слов.

Слова, которые введёт пользователь сохраним в список  anagrams_lst.

На этом этапе проверять слова не будем. Главное - не допустить повторений слов в списке anagrams_lst.




Выделим блок обработки данных в отдельную функцию. Вся логика будет находиться в функции.

```
import telebot

# Вставьте ваш токен сюда
TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
bot = telebot.TeleBot(TOKEN)

anagrams_lst = list()

word = "Апельсинка"


# Обработка данных
def append_anagrams(text):
    if text in anagrams_lst:
        return False
    else:
        anagrams_lst.append(text)
        return True


@bot.message_handler(commands=["start"])
def start_game(message):
    bot.send_message(message.chat.id, f"Придумай анаграмму к слову {word}.")


@bot.message_handler(func=lambda message: True)
def anagrama_message(message):
    # Получение данных
    text = message.text

    # Подготовка ответа
    if not append_anagrams(text):
        msg = "Такое слово уже называли!"
    else:
        msg = f"Спасибо. Запомню слово {text}."

    # Вывод данных
    bot.reply_to(message, msg)


if __name__ == "__main__":
    bot.polling(none_stop=True)
```

Что здесь происходит

Функция append_anagrams() выглядит странно. Всего 5 строчек, но столько внимания. Это сделано не напрасно. Так функцию можно отлаживать, тестировать и масштабировать. И для этого не обязательно запускать телеграм-бот.

Выполните следующие две практические работы и вставьте готовый код в свою программу, чтобы бот стал умнее.


Напишите функцию append_anagrams(), которая принимает на вход в качестве аргумента строку и добавляет её в список anagrams_lst. Если слово добавлено, то функция возвращает True, если слово добавить нельзя, то функция возвращает False.

При добавлении нужно учесть, что:

-    все буквы добавляемого слова должны быть в ключевом слове word.

-    в список anagrams_lst нужно добавлять слова только в нижнем регистре. Так будет проще искать слово в списке.

-    в список нужно добавлять только те слова, которых нет в списке.


Играть придуманными только что словами не интересно. Будет здорово, если слова будут настоящими, из словаря русского языка. Для этого придётся поработать с файлами. Скачайте и изучите файл russians1.txt переместите его в корень проекта. Именно там будет находиться файл при проверке тестирующей системой.

Напишите или дополните функцию append_anagrams(), которая принимает на вход в качестве аргумента строку и добавляет её в список anagrams_lst. Кроме всех проверок, что были сделаны в предыдущей работе, нужно проверить, есть ли такое слово среди русских слов из файла russians1.txt.

##  3.2 Бот-эрудит 


### Структурное программирование

Структурное программирование - разработка программ с помощью представления их в виде иерархической структуры блоков. Эта парадигма разработана в 70-х годах XX века Э. Дейкстрой и Н. Виртом.

Эдсгер Дейкстра (11 мая 1930 — 6 августа 2002) — нидерландский учёный, труды которого оказали влияние на развитие информатики и информационных технологий; один из разработчиков концепции структурного программирования, исследователь формальной верификации и распределённых вычислений. Тьюринговский лауреат (1972).

Никлаус Вирт (15 февраля 1934 года — 1 января 2024) — швейцарский учёный, специалист в области информатики, один из известнейших теоретиков в области разработки языков программирования, профессор компьютерных наук Швейцарской высшей технической школы Цюриха (ETHZ), лауреат премии Тьюринга 1984 года. Создатель и ведущий проектировщик языков программирования Паскаль, Модула-2, Оберон.

Любая программа представляет собой структуру, построенную из 3х типов базовых конструкций: 

-    последовательное исполнение — однократное выполнение операций в том порядке, в котором они записаны в тексте программы; 

-    ветвление — однократное выполнение одной из двух или более операций, в зависимости от выполнения некоторого заданного условия; 

-    цикл — многократное исполнение одной и той же операции до тех пор, пока выполняется некоторое заданное условие (условие продолжения цикла). 

Повторяющиеся фрагменты программы (либо не повторяющиеся, но представляющие собой логически целостные вычислительные блоки) могут оформляться в виде подпрограмм (процедур или функций). В этом случае в тексте основной программы, вместо помещённого в подпрограмму фрагмента, вставляется инструкция вызова подпрограммы. При выполнении такой инструкции выполняется вызванная подпрограмма, после чего исполнение программы продолжается с инструкции, следующей за командой вызова подпрограммы. 

Разработка программы ведётся пошагово, методом «сверху вниз».

Преимущества структурного программирования: 

- Легко подключать 

- Легко использовать 

- Легко понять 

- Легко поддерживать

 

### Когда пора писать функцию?

1. Когда программист видит, в программе несколько одинаковых строк кода. DRY -- не повторяй себя. Если код повторяется, то его следует вынести в отдельный блок. Тогда одно изменение отразится на все вызовы функции, иначе придётся искать в коде одинаковые части. Это часто приводит к ошибкам.

2. Когда программист чётко разделяет блоки кода. Например -- блок ввода, блок обработки, блок вывода. В таком случае каждый блок следует выделить в отдельную функцию.

3. Когда программа стала слишком длинной. За длинным текстом программы сложно уследить. Тогда следует вынести один из логических блоков в функцию.

4. Когда функция разрослась. Часто бывает так, что функция разрастается, тогда эту функцию следует тоже разбить на функции. Да, функция может вызывать функцию.


Напишите программу, которая запрашивает у пользователя его имя, класс и имя кл.руководителя. Затем пользователь вводит два числа через пробел — это размер прямоугольника из звездочек, которым будут разделены строчки при печати.

На прошлом уроке мы написали функцию append_anagrams(). Давайте разделим функционал. Пусть функция can_append() определяет можно ли составить слово, а добавлять в список будем в основной части программы. Функция должна принимать на вход слово пользователя, ключевое слово и список словарных слов filestr. В таком виде функцию можно будет целиком перенести в другую программу или даже включить в отдельный модуль.

Обратите внимание, что если список словарных слов filestr пуст, то функция не должна блокировать все слова подряд, а наоборот - функция не реагирует на пустой список.

Напишите функцию helper(), которая возвращает список словарных, которые можно составить из ключевого слова и списка словарных слов. Ничего кроме функции писать не нужно. Список слов, которые должна вернуть функция нужно отсортировать по длине слова и по алфавиту, если слов одинаковой длины окажется несколько.


### Команды бота

Добавьте команды /start и /help для вашего бота.

    Откройте @BotFather: Найдите @BotFather в Telegram и начните с ним чат.
    Выберите вашего бота: Используйте команду /mybots, чтобы увидеть список ваших ботов. Выберите нужного бота, нажав на его имя.
    Настройка команд: Используйте команду /setcommands, чтобы задать команды для вашего бота.
    Введите команды: Введите команды в формате command - Description, например:

    start - Старт
    help - Помощь

    Каждая команда должна быть на новой строке.
    Сохраните изменения: После ввода всех команд @BotFather подтвердит их сохранение.

Если вы успешно справились с предыдущими заданиями, то можете использовать свои функции здесь.


```
import telebot
import settings


proxy = "http://<>:<>@<>:<>"
os.environ["http_proxy"] = proxy
os.environ["HTTP_PROXY"] = proxy
os.environ["https_proxy"] = proxy
os.environ["HTTPS_PROXY"] = proxy


# Вставьте ваш токен сюда
TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
bot = telebot.TeleBot(TOKEN)

anagrams_lst = list()
word = "Апельсинка"

with open("data/russian.txt", encoding="utf-8") as f:
    filestr = f.read().split()


def helper(word, russian):
    return list()  # Это ваша функция из предыдущего задания


def can_append(text, word, russian):
    return False  # Это ваша функция из предыдущего задания


@bot.message_handler(commands=["help"])
def help_game(message):
    msg = f'Слова, которые можно составить из слова {word}: '
    msg += ', '.join(helper(word, filestr))
    bot.send_message(message.chat.id, msg)


@bot.message_handler(commands=["start"])
def start_game(message):
    bot.send_message(message.chat.id, f"Придумай анаграмму к слову {word}.")


@bot.message_handler(func=lambda message: True)
def anagrama_message(message):
    # Ввод данных
    text = message.text

    # Обработка данных
    if not can_append(text, word, filestr):
        msg = "Такое слово нельзя использовать!"
    elif text in anagrams_lst:
        msg = f"Это слово уже использовали."
    else:
        anagrams_lst.append(text)
        msg = f"Спасибо. Запомню слово {text}."

    # Вывод данных
    print(len(anagrams_lst))
    bot.reply_to(message, msg)


if __name__ == "__main__":
    bot.polling(none_stop=True)
```


Добавлен обработчик команды /help. Теперь бот сможет подсказывать слова, которые можно составить из длинного слова.

## 3.3 Словари и работа с данными 


Словари в Python — это неупорядоченные коллекции пар "ключ-значение". Они позволяют эффективно хранить и извлекать данные по ключам. Давайте рассмотрим, как создавать словари, как получать доступ к элементам и какие методы доступны для работы со словарями.
Создание словаря

Словарь можно создать несколькими способами:

1. Используя фигурные скобки:
```
my_dict = {
    'name': 'Alice',
    'age': 30,
    'city': 'New York'
}
```
2. Используя функцию dict():

my_dict = dict(name='Alice', age=30, city='New York')

3. Создание пустого словаря:

empty_dict = dict()

Доступ к элементам

Чтобы получить доступ к значению по ключу, используйте квадратные скобки или метод .get():

# Используя квадратные скобки
name = my_dict['name']
print(name)  # Вывод: Alice

# Используя метод get()
age = my_dict.get('age')
print(age)  # Вывод: 30

Метод .get() безопаснее, так как он возвращает None, если ключ не найден и не ломает программу.
Изменение и добавление элементов

Вы можете изменять значения существующих ключей или добавлять новые пары "ключ-значение":

# Изменение значения
my_dict['age'] = 31

# Добавление нового элемента
my_dict['country'] = 'USA'

print(my_dict)
# Вывод: {'name': 'Alice', 'age': 31, 'city': 'New York', 'country': 'USA'}

Удаление элементов

Для удаления элементов можно использовать оператор del или метод .pop():

# Удаление с помощью del
del my_dict['city']

# Удаление с помощью pop() и получение удаляемого значения
age = my_dict.pop('age')

print(my_dict)
# Вывод: {'name': 'Alice', 'country': 'USA'}
print(age)  # Вывод: 31

Методы словарей

Вот некоторые полезные методы для работы со словарями:

1. keys(): Возвращает представление всех ключей словаря.

keys = my_dict.keys()
print(keys)  # Вывод: dict_keys(['name', 'country'])

2. values(): Возвращает представление всех значений словаря.

values = my_dict.values()
print(values)  # Вывод: dict_values(['Alice', 'USA'])

3. items(): Возвращает представление всех пар "ключ-значение".

```
items = my_dict.items()
print(items)  # Вывод: dict_items([('name', 'Alice'), ('country', 'USA')])
```

4. clear(): Очищает словарь.

```
my_dict.clear()
print(my_dict)  # Вывод: {}
```

5. copy(): Создает поверхностную копию словаря.

```
new_dict = my_dict.copy()
print(new_dict)  # Вывод: {}
```

6. update(): Обновляет словарь, добавляя элементы из другого словаря или итерируемого объекта.

```
my_dict.update({'age': 30})
print(my_dict)  # Вывод: {'age': 30}
```
Пример использования словаря

Вот пример программы, которая использует словарь для хранения информации о человеке:

```
person = {
    'name': 'Bob',
    'age': 25,
    'city': 'Los Angeles'
}

# Доступ к элементам
print(f"Name: {person['name']}")  # Вывод Name: Bob
print(f"Age: {person.get('age')}")  # Вывод Age: 25
print(f"City: {person.get('city')}")  # Вывод City: Los Angeles

# Изменение и добавление
person['age'] += 1  # Увеличиваем возраст на 1
person['job'] = 'Engineer'  # Добавляем новую информацию

# Удаление элемента
del person['city']

# Печать оставшихся данных
print(person)  # Вывод {'name': 'Bob', 'age': 26, 'job': 'Engineer'}
```

Выводы

Словари в Python — мощный инструмент для хранения и обработки данных. Они обеспечивают быстрый доступ к значениям по ключам и имеют множество методов для удобной работы с данными.

Попробуем использовать словари для того, чтобы сохранять команды каждого пользователя отдельно и не смешивать их

```
import telebot


proxy = "http://<>:<>@<>:<>"
os.environ["http_proxy"] = proxy
os.environ["HTTP_PROXY"] = proxy
os.environ["https_proxy"] = proxy
os.environ["HTTPS_PROXY"] = proxy


# Вставьте ваш токен сюда
TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
bot = telebot.TeleBot(TOKEN)
commands_dct = dict()


@bot.message_handler(commands=["help"])
def help_game(message):
    msg = ', '.join(commands_dct[message.chat.id])
    bot.send_message(message.chat.id, msg)


@bot.message_handler(commands=["start"])
def start_game(message):
    username = message.from_user.username
    commands_dct[message.chat.id] = list()
    bot.send_message(message.chat.id, f"Привет {username}. Я буду запоминать все, что ты мне напишешь, а по команде /help я покажу тебе всё, что я запомнил.")


@bot.message_handler(func=lambda message: True)
def commands_message(message):
    text = message.text
    commands_dct[message.chat.id].append(text)
    msg = f'Длина списка: {len(commands_dct[message.chat.id])}'
    bot.reply_to(message, msg)


if __name__ == "__main__":
    bot.polling(none_stop=True)
```

Давайте протестируем этого бота. Это одна большая ошибка, но он работает!



## 3.4 Логирование 

### Логирование: Как вести логи работы бота для отладки

import logging
import telebot
import settings
import behoof_local
from telebot import types
from functools import wraps
from datetime import datetime


folder_name = "log"
if not os.path.exists(folder_name):
    os.mkdir(folder_name)

logging.basicConfig(
    filename=os.path.join(folder_name, "bot_actions.log"),
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)


def log_action(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            msg = f"Calling function: {func.__name__} "
            msg += "with args: {args[0].json} and kwargs: {kwargs}"
            logging.info(msg)
            result = func(*args, **kwargs)
            logging.info(f"Function {func.__name__} returned: {result}")
            return result
        except Exception as e:
            msg = f"Exception in function {func.__name__}: {e}"
            logging.error(msg, exc_info=True)
            raise

    return wrapper


